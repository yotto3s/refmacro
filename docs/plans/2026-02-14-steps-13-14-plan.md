# Steps 13–14: Error Reporting & Integration Tests — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Complete the refinement type system with structured error reporting (Step 13) and end-to-end integration tests + example (Step 14).

**Architecture:** Two parallel tasks on disjoint files. Step 13 modifies `check.hpp` and `subtype.hpp` to replace bare `throw "..."` strings with structured multi-line diagnostics using `FixedString<512>`. Step 14 creates new test and example files. No file conflicts between tasks.

**Tech Stack:** C++26 consteval, `refmacro::FixedString<N>`, `reftype::pretty_print()`, GTest, CMake

---

## Task A: Error Reporting (Step 13)

### Task A1: Add `report_error` helper to `check.hpp`

**Files:**
- Modify: `types/include/reftype/check.hpp:1-10` (add includes and helper)

**Step 1: Add `report_error` consteval functions**

Add after the existing `#include` block and before the `TypeResult` struct. Include `<reftype/pretty.hpp>` for pretty-printing types in error messages.

```cpp
#include <reftype/pretty.hpp>

// ... (existing includes above) ...

namespace reftype {

// ... existing using declarations ...

// --- Structured error reporting ---

// Full form: category + expected + actual + context
template <int N = 512>
consteval void report_error(const char* category,
                            const char* expected,
                            const char* actual,
                            const char* context) {
    refmacro::FixedString<N> msg{};
    msg.append("type error: ");
    msg.append(category);
    msg.append("\n  expected: ");
    msg.append(expected);
    msg.append("\n  actual:   ");
    msg.append(actual);
    msg.append("\n  at:       ");
    msg.append(context);
    throw msg.data;
}

// Short form: category + context only (no expected/actual)
template <int N = 512>
consteval void report_error(const char* category,
                            const char* context) {
    refmacro::FixedString<N> msg{};
    msg.append("type error: ");
    msg.append(category);
    msg.append("\n  at: ");
    msg.append(context);
    throw msg.data;
}

// Helper: convert BaseKind to readable string
consteval const char* kind_name(BaseKind k) {
    switch (k) {
    case BaseKind::Bool: return "Bool";
    case BaseKind::Int:  return "Int";
    case BaseKind::Real: return "Real";
    case BaseKind::None: return "<unknown>";
    }
    return "<unknown>";
}
```

**Step 2: Build and verify it compiles**

Run: `cmake --build build --target test_type_checker 2>&1 | tail -5`
Expected: Compiles successfully (no behavioral change yet)

**Step 3: Commit**

```bash
git add types/include/reftype/check.hpp
git commit -m "feat: add report_error consteval helpers for structured diagnostics"
```

---

### Task A2: Replace `throw` strings in arithmetic/negation handlers

**Files:**
- Modify: `types/include/reftype/check.hpp:98-130` (arithmetic + negation section)

**Step 1: Replace arithmetic throws (lines 112-116)**

Replace:
```cpp
        if (lk != BaseKind::Int && lk != BaseKind::Real)
            throw "type error: non-numeric operand in arithmetic";
        if (rk != BaseKind::Int && rk != BaseKind::Real)
            throw "type error: non-numeric operand in arithmetic";
        if (lk != rk)
            throw "type error: arithmetic operands must have same type";
```

With:
```cpp
        if (lk != BaseKind::Int && lk != BaseKind::Real)
            report_error("non-numeric operand in arithmetic",
                         "Int or Real", kind_name(lk), node.tag);
        if (rk != BaseKind::Int && rk != BaseKind::Real)
            report_error("non-numeric operand in arithmetic",
                         "Int or Real", kind_name(rk), node.tag);
        if (lk != rk)
            report_error("arithmetic type mismatch",
                         kind_name(lk), kind_name(rk), node.tag);
```

**Step 2: Replace negation throw (line 127)**

Replace:
```cpp
        if (ck != BaseKind::Int && ck != BaseKind::Real)
            throw "type error: non-numeric operand in negation";
```

With:
```cpp
        if (ck != BaseKind::Int && ck != BaseKind::Real)
            report_error("non-numeric operand in negation",
                         "Int or Real", kind_name(ck), "neg");
```

**Step 3: Build and run tests**

Run: `cmake --build build && ctest --test-dir build --output-on-failure -R "type_checker|compile_fail" 2>&1 | tail -20`
Expected: All tests pass (compile-fail tests still fail to compile — just with better messages)

**Step 4: Commit**

```bash
git add types/include/reftype/check.hpp
git commit -m "feat: structured error messages for arithmetic and negation"
```

---

### Task A3: Replace `throw` strings in comparison/logical/conditional handlers

**Files:**
- Modify: `types/include/reftype/check.hpp:132-184` (comparisons, logical, conditional)

**Step 1: Replace comparison throws (lines 143-147)**

Replace:
```cpp
        if (lk != BaseKind::Int && lk != BaseKind::Real)
            throw "type error: non-numeric operand in comparison";
        if (rk != BaseKind::Int && rk != BaseKind::Real)
            throw "type error: non-numeric operand in comparison";
        if (lk != rk)
            throw "type error: comparison operands must have same type";
```

With:
```cpp
        if (lk != BaseKind::Int && lk != BaseKind::Real)
            report_error("non-numeric operand in comparison",
                         "Int or Real", kind_name(lk), node.tag);
        if (rk != BaseKind::Int && rk != BaseKind::Real)
            report_error("non-numeric operand in comparison",
                         "Int or Real", kind_name(rk), node.tag);
        if (lk != rk)
            report_error("comparison type mismatch",
                         kind_name(lk), kind_name(rk), node.tag);
```

**Step 2: Replace logical throws (lines 158-160, 169)**

Replace:
```cpp
        if (get_base_kind(left.type) != BaseKind::Bool)
            throw "type error: non-boolean operand in logical operation";
        if (get_base_kind(right.type) != BaseKind::Bool)
            throw "type error: non-boolean operand in logical operation";
```

With:
```cpp
        if (get_base_kind(left.type) != BaseKind::Bool)
            report_error("non-boolean operand in logical operation",
                         "Bool", kind_name(get_base_kind(left.type)), node.tag);
        if (get_base_kind(right.type) != BaseKind::Bool)
            report_error("non-boolean operand in logical operation",
                         "Bool", kind_name(get_base_kind(right.type)), node.tag);
```

Similarly for `lnot` (line 169):
```cpp
        if (get_base_kind(child.type) != BaseKind::Bool)
            report_error("non-boolean operand in logical not",
                         "Bool", kind_name(get_base_kind(child.type)), "lnot");
```

**Step 3: Replace conditional throw (line 180)**

Replace:
```cpp
        if (get_base_kind(test.type) != BaseKind::Bool)
            throw "type error: condition must be boolean";
```

With:
```cpp
        if (get_base_kind(test.type) != BaseKind::Bool)
            report_error("condition must be boolean",
                         "Bool", kind_name(get_base_kind(test.type)), "cond");
```

**Step 4: Build and run tests**

Run: `cmake --build build && ctest --test-dir build --output-on-failure -R "type_checker|compile_fail" 2>&1 | tail -20`
Expected: All tests pass

**Step 5: Commit**

```bash
git add types/include/reftype/check.hpp
git commit -m "feat: structured error messages for comparisons, logical, and conditional"
```

---

### Task A4: Replace `throw` strings in application/lambda/fallback handlers

**Files:**
- Modify: `types/include/reftype/check.hpp:186-228` (application, lambda, fallback)

**Step 1: Replace application throw (line 207)**

Replace:
```cpp
        if (!is_arrow(fn_result.type))
            throw "type error: applying non-function";
```

With:
```cpp
        if (!is_arrow(fn_result.type)) {
            auto pp = reftype::pretty_print(fn_result.type);
            report_error("applying non-function",
                         "arrow type", pp.data, "apply");
        }
```

**Step 2: Replace standalone lambda throw (line 219)**

Replace:
```cpp
    if (str_eq(node.tag, "lambda"))
        throw "type error: cannot infer lambda type without annotation";
```

With:
```cpp
    if (str_eq(node.tag, "lambda"))
        report_error("cannot infer lambda type without annotation", "lambda");
```

**Step 3: Replace fallback throw (line 228)**

Replace:
```cpp
    throw "type error: unsupported node tag";
```

With:
```cpp
    report_error("unsupported node tag", node.tag);
```

**Step 4: Build and run tests**

Run: `cmake --build build && ctest --test-dir build --output-on-failure -R "type_checker|compile_fail" 2>&1 | tail -20`
Expected: All tests pass

**Step 5: Commit**

```bash
git add types/include/reftype/check.hpp
git commit -m "feat: structured error messages for application, lambda, and fallback"
```

---

### Task A5: Replace `throw` strings in `subtype.hpp` join function

**Files:**
- Modify: `types/include/reftype/subtype.hpp:196-228` (join function)

**Step 1: Add include for pretty.hpp at top of subtype.hpp**

Add after the existing includes:
```cpp
#include <reftype/pretty.hpp>
```

Note: This creates a circular include risk since `check.hpp` includes `subtype.hpp` and `pretty.hpp`. Verify that `pretty.hpp` only depends on `types.hpp` and `pretty_print.hpp` (which it does — no dependency on check or subtype). So adding it to subtype.hpp is safe.

Wait — actually `report_error` lives in `check.hpp`, and `subtype.hpp` is included BY `check.hpp`. So we can't call `report_error` from `subtype.hpp` without a circular dependency. Instead, build the message directly in `join()` using `FixedString`:

**Step 2: Replace join throws (lines 224, 227)**

Replace:
```cpp
        throw "type error: incompatible arrow types for join";
    }

    throw "type error: incompatible types for join";
```

With:
```cpp
        {
            refmacro::FixedString<512> msg{};
            msg.append("type error: incompatible arrow types for join\n  type 1: ");
            msg.append(reftype::pretty_print(t1));
            msg.append("\n  type 2: ");
            msg.append(reftype::pretty_print(t2));
            throw msg.data;
        }
    }

    {
        refmacro::FixedString<512> msg{};
        msg.append("type error: incompatible types for join\n  type 1: ");
        msg.append(reftype::pretty_print(t1));
        msg.append("\n  type 2: ");
        msg.append(reftype::pretty_print(t2));
        throw msg.data;
    }
```

**Step 3: Build and run ALL tests**

Run: `cmake --build build && ctest --test-dir build --output-on-failure 2>&1 | tail -20`
Expected: All tests pass

**Step 4: Commit**

```bash
git add types/include/reftype/subtype.hpp
git commit -m "feat: structured error messages for join in subtype.hpp"
```

---

### Task A6: Run full test suite and update implementation-order.md

**Step 1: Full build and test**

Run: `cmake --build build && ctest --test-dir build --output-on-failure 2>&1 | tail -30`
Expected: All tests pass (including all compile-fail tests)

**Step 2: Mark Step 13 complete in implementation-order.md**

In `docs/plans/implementation-order.md`, change:
```
- [ ] Step 13 — Error reporting ([phase8-error-reporting.md](phase8-error-reporting.md))
```
To:
```
- [x] Step 13 — Error reporting ([phase8-error-reporting.md](phase8-error-reporting.md))
```

**Step 3: Commit**

```bash
git add docs/plans/implementation-order.md
git commit -m "docs: mark Step 13 (error reporting) complete"
```

---

## Task B: Integration Test + Example (Step 14)

### Task B1: Create the integration test file

**Files:**
- Create: `types/tests/test_integration.cpp`

**Step 1: Write the integration test**

```cpp
#include <gtest/gtest.h>

#include <refmacro/control.hpp>
#include <refmacro/math.hpp>
#include <reftype/refinement.hpp>

using refmacro::Expression;
using reftype::ann;
using reftype::pos_int;
using reftype::tarr;
using reftype::TBool;
using reftype::TInt;
using reftype::TReal;
using reftype::tref;
using reftype::type_check;
using reftype::typed_full_compile;
using reftype::TypeEnv;

using E = Expression<128>;

// ============================================================
// End-to-end: type check → strip → compile → run
// ============================================================

// --- Literal pipeline ---

TEST(Integration, LiteralToFunction) {
    // ann(lit(42), TInt) → compiled function returns 42
    static constexpr auto e = ann(E::lit(42), TInt);
    constexpr auto f = typed_full_compile<e>();
    static_assert(f() == 42);
    EXPECT_EQ(f(), 42);
}

// --- Arithmetic pipeline ---

TEST(Integration, ArithmeticExpression) {
    // ann(lit(3) + lit(4) * lit(2), TInt) → 3 + 4*2 = 11
    static constexpr auto e = ann(E::lit(3) + E::lit(4) * E::lit(2), TInt);
    constexpr auto f = typed_full_compile<e>();
    static_assert(f() == 11);
    EXPECT_EQ(f(), 11);
}

TEST(Integration, ArithmeticWithVariables) {
    // ann(x + y * lit(2), TInt) with env {x:Int, y:Int}
    static constexpr auto e = ann(E::var("x") + E::var("y") * E::lit(2), TInt);
    static constexpr auto env = TypeEnv<128>{}.bind("x", TInt).bind("y", TInt);
    constexpr auto f = reftype::typed_full_compile<e, env>();
    static_assert(f(3, 4) == 11);  // 3 + 4*2
    static_assert(f(10, 5) == 20); // 10 + 5*2
    EXPECT_EQ(f(1, 1), 3);
}

// --- Conditional pipeline ---

TEST(Integration, ConditionalExpression) {
    // cond(p, lit(1), lit(0)) annotated as TInt
    static constexpr auto cond_expr =
        refmacro::make_node<128>("cond", E::var("p"), E::lit(1), E::lit(0));
    static constexpr auto e = ann(cond_expr, TInt);
    static constexpr auto env = TypeEnv<128>{}.bind("p", TBool);
    constexpr auto f = reftype::typed_full_compile<e, env>();
    static_assert(f(true) == 1);
    static_assert(f(false) == 0);
    EXPECT_EQ(f(true), 1);
    EXPECT_EQ(f(false), 0);
}

// --- Let-binding pipeline ---

TEST(Integration, LetBinding) {
    // let x = 5 in x + x → 10
    static constexpr auto let_expr = refmacro::let_<128>(
        "x", E::lit(5), E::var("x") + E::var("x"));
    static constexpr auto e = ann(let_expr, TInt);
    constexpr auto f = typed_full_compile<e>();
    static_assert(f() == 10);
    EXPECT_EQ(f(), 10);
}

TEST(Integration, NestedLetBindings) {
    // let x = 3 in let y = 4 in x + y → 7
    static constexpr auto e = ann(
        refmacro::let_<128>("x", E::lit(3),
            refmacro::let_<128>("y", E::lit(4),
                E::var("x") + E::var("y"))),
        TInt);
    constexpr auto f = typed_full_compile<e>();
    static_assert(f() == 7);
    EXPECT_EQ(f(), 7);
}

// --- Lambda pipeline ---

TEST(Integration, AnnotatedLambdaApply) {
    // let inc = ann(lambda("x", x+1), (x:Int)->Int) in apply(inc, lit(5)) → 6
    static constexpr auto lam = refmacro::lambda<128>("x", E::var("x") + E::lit(1));
    static constexpr auto arrow = tarr("x", TInt, TInt);
    static constexpr auto ann_lam = ann(lam, arrow);
    static constexpr auto e = refmacro::let_<128>("inc", ann_lam,
        refmacro::apply<128>(E::var("inc"), E::lit(5)));
    // Need env since apply(var("inc"), ...) requires inc in scope during type check
    // Actually, let binding puts inc in scope via apply(lambda(inc, body), ann_lam)
    constexpr auto f = typed_full_compile<e>();
    static_assert(f() == 6);
    EXPECT_EQ(f(), 6);
}

// --- Refinement type pipeline ---

TEST(Integration, RefinementAnnotationValid) {
    // ann(lit(5), {#v : Int | #v > 0}) — valid, compiles to 5
    static constexpr auto e = ann(E::lit(5), pos_int());
    constexpr auto f = typed_full_compile<e>();
    static_assert(f() == 5);
    EXPECT_EQ(f(), 5);
}

TEST(Integration, RefinementAnnotationInvalid) {
    // ann(lit(0), {#v : Int | #v > 0}) — invalid (0 not > 0)
    static constexpr auto e = ann(E::lit(0), pos_int());
    constexpr auto r = type_check(e);
    static_assert(!r.valid);
}

TEST(Integration, RefinementAnnotationNegativeInvalid) {
    // ann(lit(-1), {#v : Int | #v > 0}) — invalid (-1 not > 0)
    static constexpr auto e = ann(E::lit(-1), pos_int());
    constexpr auto r = type_check(e);
    static_assert(!r.valid);
}

// --- Comparison pipeline ---

TEST(Integration, ComparisonCompile) {
    // ann(x > lit(0), TBool) → runtime boolean
    static constexpr auto e = ann(E::var("x") > E::lit(0), TBool);
    static constexpr auto env = TypeEnv<128>{}.bind("x", TInt);
    constexpr auto f = reftype::typed_full_compile<e, env>();
    static_assert(f(5) == true);
    static_assert(f(0) == false);
    static_assert(f(-1) == false);
    EXPECT_TRUE(f(5));
    EXPECT_FALSE(f(0));
}

// --- Logical pipeline ---

TEST(Integration, LogicalCompile) {
    // ann(p && q, TBool) → logical AND at runtime
    static constexpr auto e = ann(E::var("p") && E::var("q"), TBool);
    static constexpr auto env = TypeEnv<128>{}.bind("p", TBool).bind("q", TBool);
    constexpr auto f = reftype::typed_full_compile<e, env>();
    static_assert(f(true, true) == true);
    static_assert(f(true, false) == false);
    EXPECT_TRUE(f(true, true));
    EXPECT_FALSE(f(false, true));
}

// --- Negation pipeline ---

TEST(Integration, NegationCompile) {
    // ann(-x, TInt) → negated value
    static constexpr auto e = ann(-E::var("x"), TInt);
    static constexpr auto env = TypeEnv<128>{}.bind("x", TInt);
    constexpr auto f = reftype::typed_full_compile<e, env>();
    static_assert(f(5) == -5);
    static_assert(f(-3) == 3);
    EXPECT_EQ(f(7), -7);
}

// --- Complex multi-step pipeline ---

TEST(Integration, ComplexPipeline) {
    // let x = 3 in cond(x > 0, x + 1, x - 1) → 4
    static constexpr auto body = refmacro::make_node<128>(
        "cond",
        E::var("x") > E::lit(0),
        E::var("x") + E::lit(1),
        E::var("x") - E::lit(1));
    static constexpr auto e = ann(
        refmacro::let_<128>("x", E::lit(3), body), TInt);
    constexpr auto f = typed_full_compile<e>();
    static_assert(f() == 4);
    EXPECT_EQ(f(), 4);
}

// --- Type check failure cases (soft failures) ---

TEST(Integration, TypeMismatchAnnotation) {
    // ann(lit(5), TBool) — Int literal annotated as Bool → invalid
    static constexpr auto e = ann(E::lit(5), TBool);
    constexpr auto r = type_check(e);
    static_assert(!r.valid);
}

TEST(Integration, LambdaOutputMismatch) {
    // ann(lambda("x", x+1), (x:Int)->Bool) — body is Int, output wants Bool
    static constexpr auto lam = refmacro::lambda<128>(
        "x", E::var("x") + E::lit(1));
    static constexpr auto arrow = tarr("x", TInt, TBool);
    static constexpr auto e = ann(lam, arrow);
    constexpr auto r = type_check(e);
    static_assert(!r.valid);
}

// --- Subtype lattice in pipeline ---

TEST(Integration, IntSubtypeOfReal) {
    // ann(lit(5), TReal) — {#v:Int|#v==5} <: Real via Int <: Real, valid
    static constexpr auto e = ann(E::lit(5), TReal);
    constexpr auto r = type_check(e);
    static_assert(r.valid);
}

// --- Typed vs untyped equivalence ---

TEST(Integration, TypedMatchesUntyped) {
    // Same expression through typed and untyped pipelines produces same result
    static constexpr auto untyped_expr = E::lit(10) - E::lit(3) * E::lit(2);
    static constexpr auto typed_expr = ann(E::lit(10) - E::lit(3) * E::lit(2), TInt);

    constexpr auto f_untyped = refmacro::full_compile<untyped_expr>();
    constexpr auto f_typed = typed_full_compile<typed_expr>();

    static_assert(f_untyped() == f_typed());
    static_assert(f_typed() == 4); // 10 - 3*2 = 4
    EXPECT_EQ(f_untyped(), f_typed());
}
```

**Step 2: Verify the test compiles and runs**

Run: `cmake --build build --target test_integration && ctest --test-dir build --output-on-failure -R Integration 2>&1 | tail -20`
Expected: All tests pass

**Step 3: Commit**

```bash
git add types/tests/test_integration.cpp
git commit -m "test: add end-to-end integration tests for typed compile pipeline"
```

---

### Task B2: Register integration test in CMakeLists

**Files:**
- Modify: `types/tests/CMakeLists.txt` (add test_integration target)

**Step 1: Add test_integration target**

Add before the `# --- Compile-fail tests ---` section:

```cmake
add_executable(test_integration test_integration.cpp)
target_link_libraries(test_integration PRIVATE reftype::reftype GTest::gtest_main)
target_compile_options(test_integration PRIVATE -Wall -Wextra -Werror)
```

And add at the end (before the final line or after existing `gtest_discover_tests`):

```cmake
gtest_discover_tests(test_integration PROPERTIES TIMEOUT 120)
```

Use timeout 120 because the full pipeline with refinement checking can be slow.

**Step 2: Build and run**

Run: `cmake --build build && ctest --test-dir build --output-on-failure -R Integration 2>&1 | tail -20`
Expected: All integration tests pass

**Step 3: Commit**

```bash
git add types/tests/CMakeLists.txt
git commit -m "build: register test_integration in CMake"
```

Note: Task B1 and B2 should be done together (write test + register in CMake) before running.

---

### Task B3: Create example program and CMake

**Files:**
- Create: `types/examples/CMakeLists.txt`
- Create: `types/examples/01_basic_refinement.cpp`
- Modify: `types/CMakeLists.txt` (add examples subdirectory)

**Step 1: Create `types/examples/CMakeLists.txt`**

```cmake
add_executable(01_basic_refinement 01_basic_refinement.cpp)
target_link_libraries(01_basic_refinement PRIVATE reftype::reftype)
target_compile_options(01_basic_refinement PRIVATE -Wall -Wextra -Werror)
```

**Step 2: Create `types/examples/01_basic_refinement.cpp`**

```cpp
// Basic refinement type system example
//
// Demonstrates: type annotations, refinement types, the typed compile pipeline.
// Build: cmake --build build --target 01_basic_refinement
// Run:   ./build/types/examples/01_basic_refinement

#include <cstdio>
#include <reftype/refinement.hpp>

using refmacro::Expression;
using reftype::ann;
using reftype::pos_int;
using reftype::TInt;
using reftype::typed_full_compile;

using E = Expression<128>;

// --- Example 1: Simple arithmetic with type annotation ---
// Expression: ann(lit(3) + lit(4), Int)
// Type checks that 3+4 produces an Int, then compiles to a function.
static constexpr auto arith_expr = ann(E::lit(3) + E::lit(4), TInt);
constexpr auto arith_fn = typed_full_compile<arith_expr>();
static_assert(arith_fn() == 7);

// --- Example 2: Refinement type annotation ---
// Expression: ann(lit(5), {#v : Int | #v > 0})
// Verifies at compile time that 5 satisfies the refinement predicate #v > 0.
static constexpr auto refined_expr = ann(E::lit(5), pos_int());
constexpr auto refined_fn = typed_full_compile<refined_expr>();
static_assert(refined_fn() == 5);

// --- Example 3: Let binding with typed compile ---
// Expression: let x = 10 in x + x → 20
static constexpr auto let_expr = ann(
    refmacro::let_<128>("x", E::lit(10), E::var("x") + E::var("x")), TInt);
constexpr auto let_fn = typed_full_compile<let_expr>();
static_assert(let_fn() == 20);

// --- Example 4: Compile-time type error detection ---
// Uncomment to see a compile-time error:
//   static constexpr auto bad = ann(E::lit(0), pos_int());
//   constexpr auto bad_fn = typed_full_compile<bad>();
// Error: 0 does not satisfy #v > 0

int main() {
    std::printf("Example 1 (3 + 4):     %d\n", static_cast<int>(arith_fn()));
    std::printf("Example 2 (lit(5)):    %d\n", static_cast<int>(refined_fn()));
    std::printf("Example 3 (let x=10): %d\n", static_cast<int>(let_fn()));
    std::printf("All examples passed!\n");
    return 0;
}
```

**Step 3: Update `types/CMakeLists.txt` to include examples**

Add at the end of the file:

```cmake
if(REFMACRO_BUILD_EXAMPLES)
    add_subdirectory(examples)
endif()
```

**Step 4: Build and run the example**

Run: `cmake --build build --target 01_basic_refinement && ./build/types/examples/01_basic_refinement`
Expected output:
```
Example 1 (3 + 4):     7
Example 2 (lit(5)):    5
Example 3 (let x=10): 20
All examples passed!
```

**Step 5: Commit**

```bash
git add types/examples/CMakeLists.txt types/examples/01_basic_refinement.cpp types/CMakeLists.txt
git commit -m "feat: add basic refinement type example program"
```

---

### Task B4: Update implementation-order.md and run full suite

**Step 1: Mark Step 14 complete**

In `docs/plans/implementation-order.md`, change:
```
- [ ] Step 14 — End-to-end integration test + example
```
To:
```
- [x] Step 14 — End-to-end integration test + example
```

**Step 2: Run the full test suite**

Run: `cmake --build build && ctest --test-dir build --output-on-failure 2>&1 | tail -30`
Expected: All tests pass

**Step 3: Commit**

```bash
git add docs/plans/implementation-order.md
git commit -m "docs: mark Step 14 (integration test + example) complete"
```

---

## Parallel Execution Notes

- **Task A (Steps A1–A6)** and **Task B (Steps B1–B4)** can be executed simultaneously by separate agents.
- Task A modifies existing headers (`check.hpp`, `subtype.hpp`).
- Task B creates new files (`test_integration.cpp`, example files, CMake updates).
- No file overlap between tasks.
- Both tasks should run the full test suite as a final verification step.
- After both tasks complete, run one final `cmake --build build && ctest --test-dir build --output-on-failure` to verify everything works together.

## Important Notes

- `FixedString<N>::data` is a `char[N]` array. Use `msg.data` (not `msg.data()`) to get a pointer for `throw`.
- `report_error()` cannot be in `subtype.hpp` due to include ordering (`check.hpp` includes `subtype.hpp`). The `join()` errors build messages inline.
- Compile-fail tests use `WILL_FAIL=TRUE` and don't depend on specific error string content — they pass as long as compilation fails.
- The `full_compile` function used in the integration test is `refmacro::full_compile` (the untyped version) — verify it exists. If not, use `refmacro::compile<expr, MAdd, MSub, MMul, MDiv, MNeg, MCond, ...>()` directly.
